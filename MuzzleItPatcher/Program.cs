using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Noggog;

namespace MuzzleItPatcher;

public class Settings
{
	/// <summary>
	/// Don't add conditions to IDLE lines with script fragments. The main idea is to avoid breaking stuff if idle lines are used to do stuff.
	/// </summary>
	public bool DoNotPatchScriptedDialog = true;
}

public class Program
{
	private static Lazy<Settings> _settings = null!;

	public static async Task<int> Main(string[] args)
	{
		return await SynthesisPipeline.Instance
			.AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
			.SetAutogeneratedSettings("MuzzleIt", "MuzzleIt", out _settings)
			.SetTypicalOpen(GameRelease.SkyrimSE, "MuzzleItPatch.esp")
			.Run(args);
	}

	public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
	{
		var formLink = new FormLink<IDialogResponsesGetter>(FormKey.Factory("0012C6:MuzzleIt.esp"));
		var exampleDialog = formLink.TryResolve(state.LinkCache);

		if (exampleDialog is null)
		{
			Console.WriteLine("Our source dialog was null!");
			return;
		}

		var conditions = exampleDialog.Conditions.Select(r => r.DeepCopy()).ToArray();

		if (conditions is null || !conditions.Any())
		{
			Console.WriteLine("Our source condition was null!");
			return;
		}

		foreach (var dialResponse in state.LoadOrder.PriorityOrder.DialogResponses().WinningContextOverrides(state.LinkCache))
		{
			if (!dialResponse.TryGetParent<IDialogTopicGetter>(out var topic))
			{
				continue;
			}

			if (topic is not
			    { Category: DialogTopic.CategoryEnum.Misc, Subtype: DialogTopic.SubtypeEnum.Idle })
			{
				continue;
			}

			if (_settings.Value.DoNotPatchScriptedDialog && DoesDialogLineHaveScriptFrag(dialResponse.Record, state))
			{
				Console.WriteLine($"{dialResponse.Record.FormKey} :: Skipped as it or a down-stream response has a script frag.");
				continue;
			}

			Console.WriteLine($"{dialResponse.Record.EditorID} => {topic.EditorID} :: {topic.Category} && {topic.Subtype}");

			var patchedResponse = dialResponse.GetOrAddAsOverride(state.PatchMod);

			patchedResponse.Conditions.InsertRange(conditions, 0);
		}

		if (formLink.TryResolveContext<ISkyrimMod, ISkyrimModGetter, IDialogResponses, IDialogResponsesGetter>(state.LinkCache, out var thing))
		{
			var patched = thing.GetOrAddAsOverride(state.PatchMod);
			patched.SkyrimMajorRecordFlags.SetFlag(SkyrimMajorRecord.SkyrimMajorRecordFlag.Deleted, true);
		}
	}

	public static bool DoesDialogLineHaveScriptFrag(IDialogResponsesGetter dialResponse, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
	{
		if (dialResponse.VirtualMachineAdapter?.ScriptFragments?.OnBegin is not null ||
		    dialResponse.VirtualMachineAdapter?.ScriptFragments?.OnEnd is not null)
		{
			return true;
		}

		foreach (var response in dialResponse.LinkTo)
		{
			if (!response.TryResolve<IDialogTopicGetter>(state.LinkCache, out var dialogLink))
			{
				continue;
			}

			foreach (var linkedDial in dialogLink.Responses)
			{
				var result = DoesDialogLineHaveScriptFrag(linkedDial, state);
				if (result)
				{
					return true;
				}
			}
		}

		return false;
	}
}